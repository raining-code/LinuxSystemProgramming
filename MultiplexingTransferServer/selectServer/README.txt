select多路转接服务器
函数原型：
int select(int ndfs,fd_set* readfds,fd_set* writefds,fd_set* exceptfds,struct timeval* timeout);
nfds是要监视的最大文件描述符的值+1
返回值：函数调用成功返回有事件就绪的文件描述符的个数

操作fd_set位图的宏(函数)：
void FD_CLR(int fd,fd_set* set);//清空某一个比特位
int FD_ISSET(int fd,fd_set* set);//测试是否被设置
void FD_SET(int fd,fd_set* set);//设置一个比特位
void FD_ZERO(fd_set* set);//清空fd_set

多路转接服务器的优势：
1.可以同时监视多个文件描述符上的事件是否就绪，将等的时间进行重叠，在一定场景下提高了效率
2.使用多路转接，可以让单进程处理多个文件描述符，因为当select函数进行返回时，一定是文件描述符上有事件就绪了，此时调用read、write、accept一定不会被阻塞

select的缺点：
1.select可以监视的文件描述符个数有限，为sizeof(fd_set)*8，因此当连接请求过多时，select无法处理后面的请求
2.select需要将fd_set结构从用户拷贝到内核，在返回时将fd_set从内核拷贝到用户，需要一定的开销
3.select底层是通过遍历fd_set结构来确定文件描述符上是否有事件就绪的，当需要监视的文件描述符比较多时，会有一定的性能损耗

什么时候读事件就绪？
1.对于监听的文件描述符而言，只要有新连接到来，说明其上有读事件就绪
2.对于普通的文件描述符，当底层接受缓冲区的数据大于低水位标记时，表示数据可以读取，读事件就绪
3.对于普通的文件描述符，如果客户端关闭连接，read函数返回0，也表示有读事件就绪，此时服务器直接关闭连接

什么时候写事件就绪？
当底层发送缓冲区的剩余容量大于阈值时，表示可以向发送缓冲区写入数据，此时调用write不会被阻塞

什么情况下不适合用多路转接select?
当连接比较多并且都比较活跃时，此时进行I/O，大部分时间都在进行拷贝，而不是等，此时使用多线程服务器更加合适，例如客户端与服务端互相传输文件
什么情况下适合用多路转接select？
在客户端与服务器通信过程中，服务端大部分时间都在等，等待数据就绪，此时就可以使用select将等的时间进行重叠，例如QQ
在使用QQ进行群聊时，QQ服务器等待我们发送数据，可以使用select，同时等待多个客户端发送数据，当有一个客户端发送数据时，QQ服务器可以进行广播发送给客户端
